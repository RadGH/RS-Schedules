<?php

/**
 * Alchemy Updater
 *
 * Created by Radley Sustaire
 * Created on 2025-09-18
 * Version 1.0.3
 *
 * This script can be included with any plugin to enable automatic updates.
 * Your plugin should have the header "Alchemy Update URI" with a URL pointing to the plugin metadata JSON.
 * The JSON file is generated by the Alchemy Update Server, which must exist in an external server and is used to manage versions.
 *
 * Get the latest version of this script from GitHub (Alchemy + Aim Private Repository):
 * @see https://github.com/alchemyandaim/alchemy-updater
 */

if ( ! class_exists('Alchemy_Updater') ) :
	class Alchemy_Updater {
		
		public static $version = '1.0.3';
		
		public static $cached_results = array();
		
		public function __construct() {
			
			// Add the Alchemy Update URI header to the list of recognized plugin and theme headers.
			add_filter( 'extra_plugin_headers', array( $this, 'add_comment_header' ) );
			add_filter( 'extra_theme_headers', array( $this, 'add_comment_header' ) );
			
			// When WordPress checks for plugin updates, also update Alchemy Updater plugins.
			add_filter( 'site_transient_update_plugins', array( $this, 'check_plugin_updates' ) );
			
			// When WordPress checks for theme updates, also update Alchemy Updater themes.
			add_filter( 'site_transient_update_themes', array( $this, 'check_theme_updates' ) );
			
			// Display plugin info in the popup
			add_filter( 'plugins_api', array( $this, 'display_plugin_info' ), 20, 3 );
			
		}
		
		// Singleton instance
		protected static $instance = null;
		
		public static function get_instance() {
			if ( !isset( self::$instance ) ) self::$instance = new static();
			return self::$instance;
		}
		
		// Utilities
		
		/**
		 * Gets a full plugin path ("something/something.php") by its slug ("something").
		 *
		 * @param string $plugin_slug
		 *
		 * @return string|false
		 */
		public function get_plugin_path_by_slug( $plugin_slug ) {
			$all_plugins = get_plugins();
			
			foreach ( $all_plugins as $path => $data ) {
				if ( stripos( $path, $plugin_slug . '/' ) === 0 || strtolower($path) === strtolower($plugin_slug . '.php') ) {
					return $path;
				}
			}
			
			return false;
		}
		
		/**
		 * Gets a plugin slug ("something") by its full plugin path ("something/something.php").
		 *
		 * @param string $plugin_slug
		 *
		 * @return string|false
		 */
		public function get_plugin_slug_from_path( $plugin_slug ) {
			$all_plugins = get_plugins();
			
			foreach ( $all_plugins as $path => $data ) {
				if ( strtolower($path) === strtolower($plugin_slug) ) {
					$parts = explode( '/', $path );
					return strtolower( $parts[0] );
				}
			}
			
			return false;
		}
		
		/**
		 * Gets the plugin version from its slug
		 *
		 * @param string $plugin_path
		 *
		 * @return string|false
		 */
		public function get_plugin_version( $plugin_path ) {
			$plugin_path = WP_PLUGIN_DIR . '/' . $plugin_path;
			$plugin_data = get_plugin_data( $plugin_path );
			
			if ( $plugin_data ) {
				return $plugin_data['Version'];
			}
			
			return false;
		}
		
		/**
		 * Get the cache key that stores the plugin update metadata
		 *
		 * @param string $plugin_path
		 *
		 * @return string
		 */
		public function get_plugin_cache_key( $plugin_path ) {
			return 'alchemy_updater_plugin_' . md5( $plugin_path );
		}
		
		/**
		 * Get the cache key that stores the theme update metadata
		 *
		 * @param string $stylesheet
		 *
		 * @return string
		 */
		public function get_theme_cache_key( $stylesheet ) {
			return 'alchemy_updater_theme_' . md5( $stylesheet );
		}
		
		
		/**
		 * Stores a response as a transient.
		 *
		 * @param string $type     'plugin' or 'theme'
		 * @param string $slug     Plugin path or theme stylesheet
		 * @param mixed $data      The data to store
		 * @param int $expires_in  Expiration time in seconds (default 30 days)
		 *
		 * @return void
		 */
		public function store_response( $type, $slug, $data, $expires_in = DAY_IN_SECONDS * 30 ) {
			$cache_key = $type === 'plugin' ? $this->get_plugin_cache_key( $slug ) : $this->get_theme_cache_key( $slug );
			
			$result = array(
				'response_date' => date('Y-m-d H:i:s'),
				'data'          => $data,
			);
			
			// Store as a transient between sessions
			set_transient( $cache_key, $result, $expires_in );
			
			// Store in the static cache for this request
			self::$cached_results[ $cache_key ] = $result;
		}
		
		/**
		 * Gets a stored response from a transient, unless it exceeds the specified $expires_in time, separate from the transient expiration.
		 *
		 * @param string $type          'plugin' or 'theme'
		 * @param string $slug          Plugin path or theme stylesheet
		 * @param int|null $expires_in  Expiration time in seconds (default: null, meaning no expiration check)
		 *
		 * @return mixed|null
		 */
		public function get_stored_response( $type, $slug, $expires_in = null ) {
			$cache_key = $type === 'plugin' ? $this->get_plugin_cache_key( $slug ) : $this->get_theme_cache_key( $slug );
			
			// Get from cache (this session)
			$result = self::$cached_results[ $cache_key ] ?? null;
			
			// If that failed, get from transient (previous session)
			if ( $result === null ) {
				if ( isset($_GET['force-check']) ) {
					// If "force-check" is set in the URL, ignore stored responses
					return null;
				}else{
					// Otherwise get the stored transient
					$result = get_transient( $cache_key );
				}
			}
			
			// Check if the result is valid
			if ( ! $result || ! isset( $result['data'] ) ) return null;
			
			// Check if the response date exceeds the $expires_in limit
			if ( $expires_in ) {
				$date = $result['response_date'];
				$ts = strtotime( $date );
				if ( ! $ts || abs( time() - $ts ) > $expires_in ) {
					return null;
				}
			}
			
			return $result['data'];
		}
		
		/**
		 * Returns the number of seconds between update checks.
		 *
		 * @param string $type  'plugin' or 'theme'
		 * @param string $slug  Plugin path or theme stylesheet
		 *
		 * @return float|int
		 */
		public function get_refresh_interval( $type, $slug ) {
			$interval = HOUR_IN_SECONDS * 6; // 6 hours
			
			$interval = apply_filters( 'alchemy_updater/refresh_interval', $interval, $type, $slug );
			
			return $interval;
		}
		
		// Internal Hooks
		
		/**
		 * Gets the Alchemy update URL for a plugin from its headers
		 *
		 * @param string $plugin_path
		 *
		 * @return string|false
		 */
		public function get_alchemy_update_url_for_plugin( $plugin_path ) {
			// Get plugin header data
			$plugin_data = get_plugin_data( WP_PLUGIN_DIR . '/' . $plugin_path );
			
			return $plugin_data['Alchemy Update URI'] ?: false;
		}
		
		/**
		 * Gets the Alchemy update URL for a theme from its headers
		 *
		 * @param string $stylesheet
		 *
		 * @return string|false
		 */
		public function get_alchemy_update_url_for_theme( $stylesheet ) {
			$themes = wp_get_themes();
			if ( ! isset( $themes[ $stylesheet ] ) ) return false;
			
			return $themes[ $stylesheet ]->get( 'Alchemy Update URI' ) ?: false;
		}
		
		/**
		 * Checks a single plugin for updates
		 *
		 * @param string $plugin_path
		 * @param string|null $current_version
		 * @param string|null $update_url
		 *
		 * @return array|false
		 */
		public function check_single_plugin_for_updates( $plugin_path, $current_version = null, $update_url = null ) {
			if ( $current_version === null ) {
				$current_version = $this->get_plugin_version( $plugin_path );
			}
			
			if ( $update_url === null ) {
				$update_url = $this->get_alchemy_update_url_for_plugin( $plugin_path );
			}
			
			if ( ! $update_url ) return false;
			
			// Check if we already have a recent response stored. Check every 6 hours.
			$interval = $this->get_refresh_interval( 'plugin', $plugin_path );
			$update_data = $this->get_stored_response( 'plugin', $plugin_path, $interval );
			if ( $update_data !== null ) return $update_data;
			
			// Request the remote JSON metadata URL
			$response = wp_remote_get( $update_url );
			if ( is_wp_error( $response ) ) return false;
			
			$response_code = wp_remote_retrieve_response_code( $response );
			if ( $response_code != 200 ) return false;
			
			$body = wp_remote_retrieve_body( $response );
			if ( ! $body ) return false;
			
			$data = json_decode( $body, true );
			if ( empty( $data['versions'] ) ) return false;
			
			// Get the latest version
			$latest_version = array_key_first( $data['versions'] );
			$latest_info = $data['versions'][ $latest_version ];
			
			if ( version_compare( $latest_version, $current_version, '>' ) ) {
				$plugin_slug = $this->get_plugin_slug_from_path( $plugin_path );
				
				$result = array(
					'alchemy_updater' => self::$version,
					'slug'            => $plugin_slug,
					'plugin'          => $plugin_path,
					'new_version'     => $latest_info['version'],
					'url'             => $data['website_url'],  // Optional plugin info page
					'package'         => $latest_info['download_url'],
					'tested'          => $latest_info['tested'],
					'requires'        => $latest_info['requires'],
					'metadata'        => array(
						'name'          => $data['plugin_name'],
						'website_url'   => $data['website_url'],
						'github_url'    => $data['github_url'],
						'changelog'     => $latest_info['changelog'],
						'release_date'  => $latest_info['release_date'],
					),
				);
			}else{
				// No update needed
				$result = false;
			}
			
			// Store the result for up to 30 days
			$this->store_response( 'plugin', $plugin_path, $result );
			
			return $result;
		}
		
		/**
		 * Checks a single theme for updates
		 *
		 * @param string $stylesheet
		 * @param string|null $current_version
		 * @param string|null $update_url
		 *
		 * @return array|false
		 */
		public function check_single_theme_for_updates( $stylesheet, $current_version = null, $update_url = null ) {
			$themes = wp_get_themes();
			
			if ( ! isset( $themes[ $stylesheet ] ) ) return false;
			
			$theme = $themes[ $stylesheet ];
			
			if ( $current_version === null ) {
				$current_version = $theme->get( 'Version' );
			}
			
			if ( $update_url === null ) {
				$update_url = $this->get_alchemy_update_url_for_theme( $stylesheet );
			}
			
			if ( ! $update_url ) return false;
			
			// Check if we already have a recent response stored. Check every 6 hours.
			$interval = $this->get_refresh_interval( 'theme', $stylesheet );
			$update_data = $this->get_stored_response( 'theme', $stylesheet, $interval );
			if ( $update_data !== null ) return $update_data;
			
			// Request the remote JSON metadata URL
			$response = wp_remote_get( $update_url );
			if ( is_wp_error( $response ) ) return false;
			
			$response_code = wp_remote_retrieve_response_code( $response );
			if ( $response_code != 200 ) return false;
			
			$body = wp_remote_retrieve_body( $response );
			if ( ! $body ) return false;
			
			$data = json_decode( $body, true );
			if ( empty( $data['versions'] ) ) return false;
			
			$latest_version = array_key_first( $data['versions'] );
			$latest_info = $data['versions'][ $latest_version ];
			
			if ( version_compare( $latest_version, $current_version, '>' ) ) {
				$result = array(
					'alchemy_updater' => self::$version,
					'theme'           => $stylesheet,
					'new_version'     => $latest_info['version'],
					'url'             => $data['website_url'],
					'package'         => $latest_info['download_url'],
					'tested'          => $latest_info['tested'],
					'requires'        => $latest_info['requires'],
					'metadata'        => array(
						'name'          => $data['plugin_name'],
						'website_url'   => $data['website_url'],
						'github_url'    => $data['github_url'],
						'changelog'     => $latest_info['changelog'],
						'release_date'  => $latest_info['release_date'],
					),
				);
			}else{
				// No update needed
				$result = false;
			}
			
			// Store the result for up to 30 days
			$this->store_response( 'theme', $stylesheet, $result );
			
			return $result;
		}
		
		/**
		 * Adds the Alchemy Update URI header to the list of recognized plugin headers.
		 *
		 * @param string[] $headers
		 *
		 * @return string[]
		 */
		public function add_comment_header( $headers ) {
			$headers['Alchemy Update URI'] = 'Alchemy Update URI';
			return $headers;
		}
		
		// Public Hooks
		
		/**
		 * When WordPress checks for plugin updates, also update Alchemy Updater plugins.
		 *
		 * @param stdClass $transient
		 *
		 * @return stdClass
		 */
		function check_plugin_updates( $transient ) {
			if ( empty( $transient->checked ) ) return $transient;
			
			// Collect which plugins are managed by Alchemy Updater
			$managed_plugins = array();
			
			// Check each plugin to see if it is managed by Alchemy Updater
			foreach( $transient->checked as $plugin_path => $version ) {
				$update_url = $this->get_alchemy_update_url_for_plugin( $plugin_path );
				if ( $update_url ) {
					$managed_plugins[ $plugin_path ] = array(
						'version' => $version,
						'update_url' => $update_url,
					);
				}
			}
			
			// Abort if no plugins managed by Alchemy Updater
			if ( empty( $managed_plugins ) ) return $transient;
			
			// Check each plugin and store the response in the transient
			foreach( $managed_plugins as $plugin_path => $data ) {
				$result = $this->check_single_plugin_for_updates( $plugin_path, $data['version'], $data['update_url'] );
				
				if ( $result ) {
					$transient->response[ $plugin_path ] = (object) $result;
				}
			}
			
			return $transient;
		}
		
		/**
		 * When WordPress checks for theme updates, also update Alchemy Updater themes.
		 *
		 * @param stdClass $transient
		 *
		 * @return stdClass
		 */
		function check_theme_updates( $transient ) {
			$themes = wp_get_themes();
			
			foreach ( $themes as $stylesheet => $theme ) {
				$result = $this->check_single_theme_for_updates( $stylesheet );
				
				if ( $result ) {
					$transient->response[ $stylesheet ] = $result;
				}
			}
			
			return $transient;
		}
		
		/**
		 * Display plugin info in the popup
		 *
		 * @param stdClass|false $result
		 * @param string $action
		 * @param array $args {
		 *    @type string $slug     - The short plugin slug (does not include folder or file extension)
		 *    @type string $plugin
		 *    @type string $version
		 * }
		 *
		 * @return stdClass
		 */
		public function display_plugin_info( $result, $action, $args ) {
			if ( $action !== 'plugin_information' || empty( $args->slug ) ) return $result;
			
			$plugin_path = $this->get_plugin_path_by_slug( $args->slug );
			if ( ! $plugin_path ) return $result;
			
			// Check if the plugin supports Alchemy Updater based on its update URL
			$update_url = $this->get_alchemy_update_url_for_plugin( $plugin_path );
			if ( ! $update_url ) return $result;
			
			// Get the stored result from the last plugin update check
			$update_data = $this->get_stored_response( 'plugin', $plugin_path );
			if ( ! $update_data ) return $result;
			
			// Read plugin headers to find update URI
			$plugin_data = get_plugin_data( WP_PLUGIN_DIR . '/' . $plugin_path );
			
			// Collect data
			$description = $plugin_data['Description'] ?: '';
			
			$metadata = $update_data['metadata'] ?? array();
			
			$name = $metadata['name'] ?? $args->slug;
			$website_url = $metadata['website_url'] ?? '';
			$changelog = $metadata['changelog'] ?? '';
			
			// Prepare sections
			$sections = array();
			
			if ( $description || $website_url ) {
				$desc = array();
				
				if ( $description ) {
					$desc[] = $description;
				}
				if ( $website_url ) {
					$desc[] = 'Visit the plugin page: <a href="' . esc_url( $website_url ) . '">' . esc_html( $website_url ) . '</a>';
				}
				
				$sections['description'] = wpautop( implode( "\n\n", $desc ) );
			}
			
			if ( $changelog ) {
				if ( function_exists('acf_parse_markdown') ) {
					$changelog = acf_parse_markdown( $changelog );
				} else {
					$changelog = wpautop( $changelog );
				}
				$sections['changelog'] = $changelog;
				
			}
			
			// Return the data
			return (object) [
				'name'          => $name,
				'slug'          => $args->slug,
				'version'       => $update_data['new_version'],
				'requires'      => $update_data['requires'],
				'tested'        => $update_data['tested'],
				'download_link' => $update_data['package'],
				'sections'      => $sections,
			];
		}
		
	}
endif;

// Initialize the updater
Alchemy_Updater::get_instance();
